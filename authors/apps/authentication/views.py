import os
import uuid
from django.conf import settings
from django.contrib.sites.shortcuts import get_current_site
from django.core.mail import send_mail
from django.utils.http import urlsafe_base64_decode, urlsafe_base64_encode
from django.utils.encoding import force_bytes
from django.urls import reverse

from rest_framework import status
from rest_framework.generics import RetrieveUpdateAPIView, GenericAPIView
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from ..core.password_reset_manager import PasswordResetManager

from .renderers import UserJSONRenderer
from .serializers import (
    LoginSerializer, RegistrationSerializer, UserSerializer,
    PasswordResetRequestSerializer, PasswordResetSerializer,
    TwitterAuthSerializer, GoogleFacebookAuthSerializer
)
import os
import twitter
import facebook
from google.oauth2 import id_token
from google.auth.transport import requests
from .social_login import(login_or_register_social_user)
from .models import User


class RegistrationAPIView(GenericAPIView):
    # Allow any user (authenticated or not) to hit this endpoint.
    permission_classes = (AllowAny,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = RegistrationSerializer

    def post(self, request):
        """
        Method to handle post requests for user registration
        :params:
        request:- holds the request a user sends to the server.
        :returns:
        username:- the username provided by user.
        email:- the email provided by user.
        token:- the JWT generated by server, for user to access protected
        endpoints.
        """
        user = request.data.get(
            'user', {}) if 'user' in request.data else request.data
        serializer = self.serializer_class(data=user)
        serializer.is_valid(raise_exception=True)
        new_user = serializer.save()

        token = new_user.token
        new_user.is_active = False
        new_user.save()
        current_site = get_current_site(request)
        resp_data = self.email_notification(
            new_user, current_site, token)

        return Response(resp_data, status=status.HTTP_201_CREATED)

    def email_notification(self, user, current_site, token):
        """
        Method to send an email notification to a registered user.
        :params:
        user:- holds a registered user's details.
        current_site:- holds the users route.
        token:- holds the token created for the user.
        :returns:
        response_data:- holds a 'mail-sent' message and the route to
        the activation view.
        """
        verification_route = reverse('authentication:activate', args=[token])
        domain = f'http://{current_site.domain}'
        link = f'{domain}{verification_route}'
        # send_mail(subject, message, from_email, to_list, fail_silently=True)
        subject = "Activation for your Author's Haven account"
        message = f'Thank you, Please Activate your account below.\n{link}'
        from_mail = settings.EMAIL_HOST_USER
        to_mail = [user.email]

        send_mail(subject, message, from_mail, to_mail, fail_silently=True)

        response_data = {
            "email": user.email,
            "username": user.username,
            "msg": f'An email verification has been sent to {user}.'
        }

        return response_data


class AccountActivateAPIView(GenericAPIView):
    # Activate account after user clicks on emailed activation link.
    permission_classes = (AllowAny,)
    serializer_class = UserSerializer

    def get(self, request, token):
        """
        Method to activate a registered user account.
        :params:
        request:- holds user's request.
        uuid:- holds unique ID returned by user
        token:- holds the token from the user.
        :returns:
        response_data:- holds notification of activated user account
        and respective email.
        """
        user_id = User.decode_token(token)
        if not isinstance(user_id, int):
            return Response(
                {'err_msg': user_id}, status=status.HTTP_400_BAD_REQUEST)
        try:
            user = User.objects.get(pk=user_id)
        except User.DoesNotExist as e:
            return Response(
                {'err_msg': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        if user and not user.is_active:
            user.is_active = True
            user.save()
            resp = {
                "msg": "Your account is activated, enjoy",
                "user": user.email
            }
            return Response(resp, status=status.HTTP_200_OK)
        elif user.is_active:
            return Response({
                "msg": "This account is already activated"
            }, status=status.HTTP_400_BAD_REQUEST)


class LoginAPIView(GenericAPIView):
    permission_classes = (AllowAny,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = LoginSerializer

    def post(self, request):
        user = request.data.get(
            'user', {}) if 'user' in request.data else request.data

        # Notice here that we do not call `serializer.save()` like we did for
        # the registration endpoint. This is because we don't actually have
        # anything to save. Instead, the `validate` method on our serializer
        # handles everything we need.
        serializer = self.serializer_class(data=user)
        serializer.is_valid(raise_exception=True)

        return Response(serializer.data, status=status.HTTP_200_OK)


class UserRetrieveUpdateAPIView(RetrieveUpdateAPIView):
    permission_classes = (IsAuthenticated,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = UserSerializer

    def retrieve(self, request, *args, **kwargs):
        # There is nothing to validate or save here. Instead, we just want the
        # serializer to handle turning our `User` object into something that
        # can be JSONified and sent to the client.
        serializer = self.serializer_class(request.user)

        return Response(serializer.data, status=status.HTTP_200_OK)

    def update(self, request, *args, **kwargs):
        serializer_data = request.data.get(
            'user', {}) if 'user' in request.data else request.data

        # Here is that serialize, validate, save pattern we talked about
        # before.
        serializer = self.serializer_class(
            request.user, data=serializer_data, partial=True
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data, status=status.HTTP_200_OK)


class TwitterAuthAPIView(GenericAPIView):
    """
    Handle login of a Twitter user via the Twitter Api. 
    The Twitter Api takes parameters of consummer key, consumer secret,
    access token and access token secret. It then verifies the credentials
    and returns the twitter user information

    login_or_register_social_user method, takes in twitter user object and
    verifies if the user is already in the database and returns logged in user
    with a login token if user exists in database. Else, it registers the user
    and logs in the user
    """
    permission_classes = (AllowAny,)
    serializer_class = TwitterAuthSerializer

    def post(self, request):
        """This method returns a logged in Twitter user"""
        access_token = request.data.get('access_token', {})
        access_token_secret = request.data.get('access_token_secret', {})

        serializer = self.serializer_class(data={'access_token': access_token,
                                    'access_token_secret': access_token_secret
                                                 })
        serializer.is_valid(raise_exception=True)

        # verify and return twitter user information
        twitter_client_key = os.getenv('TWITTER_OAUTH1_KEY')
        twitter_client_secret = os.getenv('TWITTER_OAUTH1_SECRET')

        api = twitter.Api(consumer_key=twitter_client_key,
                          consumer_secret=twitter_client_secret,
                          access_token_key=access_token,
                          access_token_secret=access_token_secret)

        twitter_user = api.VerifyCredentials(include_email="true")
        twitter_user = twitter_user.__dict__

        return login_or_register_social_user(twitter_user)


class GoogleAuthAPIView(GenericAPIView):
    """
    Handle login of a Google user via the Google oauth2. 
    id_token is an open id that allows Clients to verify the identity of the 
    End-User based on the authentication performed by an Authorization Server, 
    as well as to obtain basic profile information about the End-User in an 
    interoperable and REST-like manner.

    login_or_register_social_user method, takes in google user object and
    verifies if the user is already in the database and returns logged in user
    with a login token if user exists in database. Else, it registers the user
    and logs in the user
    """
    permission_classes = (AllowAny,)
    serializer_class = GoogleFacebookAuthSerializer

    def post(self, request):
        """This method returns a logged in Google user"""
        access_token = request.data.get('access_token', {})

        serializer = self.serializer_class(data={'access_token': access_token})
        serializer.is_valid(raise_exception=True)

        # verify and return google user information
        google_user = id_token.verify_oauth2_token(
            access_token, requests.Request())

        return login_or_register_social_user(google_user)


class FacebookAuthAPIView(GenericAPIView):
    """
    Handle login of a Facebook user via the Facebook Graph API. 
    The Graph API returns a graph object that contains user information

    login_or_register_social_user method, takes in Facebook user object and
    verifies if the user is already in the database and returns logged in user
    with a login token if user exists in database. Else, it registers the user
    and logs in the user
    """
    permission_classes = (AllowAny,)
    serializer_class = GoogleFacebookAuthSerializer

    def post(self, request):
        """This method returns a logged in Facebook user"""
        access_token = request.data.get('access_token', {})

        serializer = self.serializer_class(data={'access_token': access_token})
        serializer.is_valid(raise_exception=True)

        # verify and return facebook user information
        graph = facebook.GraphAPI(access_token=access_token)
        facebook_user = graph.get_object(id='me', fields='email, name')

        return login_or_register_social_user(facebook_user)


class PasswordResetRequestAPIView(GenericAPIView):
    """
    This handles receiving the requester's email address and sends
    a password reset email
    """
    permission_classes = (AllowAny,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = PasswordResetRequestSerializer

    def post(self, request):
        user = request.data.get(
            'user', {}) if 'user' in request.data else request.data
        serializer = self.serializer_class(data=user)
        serializer.is_valid(raise_exception=True)
        user_email = user.get("email", None)
        PasswordResetManager(request).send_password_reset_email(user_email)
        msg = "An email has been sent to your \
            mailbox with instructions to reset your password"
        return Response(
            {
                "message": msg,
            },
            status=status.HTTP_200_OK
        )


class PasswordResetAPIView(GenericAPIView):
    """
    This handles verification of reset link and updates password field
    with new password
    """
    permission_classes = (AllowAny,)
    renderer_classes = (UserJSONRenderer,)
    serializer_class = PasswordResetSerializer

    def get(self, request, token):
        user = PasswordResetManager(request).get_user_from_encoded_token(token)
        if user is None:
            return Response({"message": "Invalid token!"},
                            status=status.HTTP_400_BAD_REQUEST)
        return Response(
            {
                "message": (
                    "Token is valid. OK to send new password information"
                )
            },
            status=status.HTTP_200_OK
        )

    def post(self, request, token):
        data = request.data.get(
            'user', {}) if 'user' in request.data else request.data
        user = PasswordResetManager(request).get_user_from_encoded_token(token)
        if user is None:
            return Response(
                {
                    "message": "Your token has expired. Please start afresh."
                },
                status=status.HTTP_400_BAD_REQUEST
            )
        email = user.get('email')
        serializer = self.serializer_class(data=data)
        serializer.is_valid(raise_exception=True)
        new_password = data.get("new_password")
        PasswordResetManager(request).update_password(email, new_password)
        return Response({"message": "Your password has been reset"},
                        status=status.HTTP_200_OK)
